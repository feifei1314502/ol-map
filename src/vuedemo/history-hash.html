<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /**
         * hash 模式是一种把前端路由的路径用井号 # 拼接在真实 url 后面的模式。当井号 # 后面的路径发生变化时，浏览器并不会重新发起请求，而是会触发 onhashchange 事件。
         * 
         * //http://127.0.0.1:8001/01-hash.html?a=100&b=20#/aaa/bbb
         * https://juejin.cn/post/6993840419041706014
         * 
            location.protocal // 'http:' 协议
            localtion.hostname // '127.0.0.1' 主机名
            location.host // '127.0.0.1:8001' 主机
            location.port //8001 端口号
            location.pathname //'01-hash.html' 访问页面
            location.serach // '?a=100&b=20' 搜索内容
            location.hash // '#/aaa/bbb' 哈希值

            hash变化会触发网页跳转，即浏览器的前进和后退
            hash 可以改变 url ，但是不会触发页面重新加载（hash的改变是记录在 window.history 中），即不会刷新页面。也就是说，
            所有页面的跳转都是在客户端进行操作。因此，这并不算是一次 http 请求，
            所以这种模式不利于 SEO 优化。hash 只能修改 # 后面的部分，
            所以只能跳转到与当前 url 同文档的 url 。

            hash 通过 window.onhashchange 的方式，来监听 hash 的改变，借此实现无刷新跳转的功能。
            hash 永远不会提交到 server 端
         * 

         hash模式是通过改变锚点(#)来更新页面URL，并不会触发页面重新加载，我们可以通过window.onhashchange监听到hash的改变，从而处理路由。
         history模式是通过调用window.history对象上的一系列方法来实现页面的无刷新跳转。
         * **/
    </script>

    <script>
      //hash 使用 win.onhashChange
      //history win.history
      // 在hash模式下，所有的页面跳转都是客户端进行操作，因此对于页面拦截更加灵活；但每次url的改变不属于一次http请求，所以不利于SEO优化。
      // 在history模式下，借助history.pushState实现页面的无刷新跳转；这种方式改变了url，如果重新刷新页面会造成一个新的http请求，因此会重新请求服务器，这也使得我们必须在服务端配置好地址，否则服务端会返回404，为确保不出问题，最好在项目中配置404页面
    </script>
  </body>
</html>
